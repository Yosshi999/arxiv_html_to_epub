<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>arXiv.html to EPUB</title>
    <script src="jszip.min.js"></script>
    <style>
    body {
      font-family: sans-serif;
      background: #f5f7fa;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    header {
      background: white;
      width: 100%;
      padding: 20px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .container {
      max-width: 800px;
      width: 100%;
      margin: 30px auto 0 auto;
      background: white;
      padding: 20px 25px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    input[type=text] {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-sizing: border-box;
    }
    .convert-section {
      display: flex;
      margin-top: 10px;
    }
    #status {
      margin-left: 15px;
      align-self: center;
    }
    .error {
      color: red;
    }
    button {
      padding: 10px 18px;
      font-size: 16px;
      border: none;
      background: #007bff;
      color: white;
      border-radius: 6px;
      cursor: pointer;
    }
    button:disabled {
      background: lightgray;
      cursor: not-allowed;
    }
    #preview {
      height: 800px;
    }
    #previewFrame {
      width: 100%;
      height: 100%;
    }
    </style>
</head>
<body>
    <header>
        <h1>arXiv.html to EPUB Converter</h1>
        <p>Enter an arXiv ID to convert to EPUB format.</p>
    </header>
    <div class="container">
        <label for="arxivInput">Enter arXiv ID or URL:</label>
        <input type="text" id="arxivInput" placeholder="1706.03762v7">
        <div class="convert-section">
            <button id="convertButton">Convert</button>
            <div id="status"></div>
        </div>
    </div>
    <div id="preview" class="container" style="display:none">
        <iframe id="previewFrame" sandbox="allow-same-origin"></iframe>
    </div>

    <footer style="text-align:center; font-size:small; color:gray; margin:20px;">
        <p>
            Thank you to arXiv for use of its open access interoperability. This service was not reviewed or approved by, nor does it necessarily express or reflect the policies or opinions of, arXiv.
        </p>
    </footer>

    <script type="module">
        const arxivInput = document.getElementById("arxivInput");
        const convertButton = document.getElementById("convertButton");
        const statusDiv = document.getElementById("status");
        const previewDiv = document.getElementById("preview");
        const previewFrame = document.getElementById("previewFrame");
        const escapeXml = (unsafe) =>
            unsafe.replace(/[<>&'"]/g, (c) => `&${({
                '<': 'lt',
                '>': 'gt',
                '&': 'amp',
                '\'': 'apos',
                '"': 'quot'
            })[c]};`);

        const expectedStyleNames = [
            "arxiv-html-papers-20250916.css"
        ];

        function extractArxivId(input) {
            const arxivIdPattern = /([0-9]{4}\.[0-9]{4,5}(v[0-9]+)?)/i;
            const match = input.match(arxivIdPattern);
            return match ? match[1] : null;
        }

        function errorMessage(message) {
            statusDiv.textContent = message;
            statusDiv.className = "error";
        }

        function infoMessage(message) {
            statusDiv.textContent = message;
            statusDiv.className = "";
        }

        convertButton.addEventListener("click", async () => {
            const id = extractArxivId(arxivInput.value);
            console.log("Extracted arXiv ID:", id);
            if (!id) {
                errorMessage("Invalid arXiv ID or URL.");
                return;
            }
            const url = `https://arxiv.org/html/${id}/`;
            infoMessage(`Fetching ${url}...`);
            convertButton.disabled = true;
            
            try {
                const html = await fetch(url).then(res => {
                    if (!res.ok) throw new Error("Failed to fetch article.");
                    return res.text();
                });
                const doc = new DOMParser().parseFromString(html, "text/html");
                const title = doc.querySelector(".ltx_title_document")?.textContent || "arXiv";
                console.log("Document title:", title);
                infoMessage("Processing article...");
                // Extract main content
                const article = doc.querySelector(".ltx_page_content");
                if (!article) {
                    throw new Error("Failed to find article content.");
                }
                const watermarkElm = doc.querySelector("#target-section");
                const titleElm = doc.querySelector(".ltx_title_document");
                const authorsElm = doc.querySelector(".ltx_authors");
                const abstElm = doc.querySelector("#abstract");
                const sections = Array.from(doc.querySelectorAll("article > section"));

                // Extract CSS link
                let styles = "";
                const cssLinks = Array.from(doc.querySelectorAll("link[rel='stylesheet']")).map(link => link.getAttribute("href"));
                const resolvedCssNames = cssLinks.map(link => new URL(link, url).pathname);
                for (const cssName of resolvedCssNames) {
                    const cssBaseName = cssName.substring(cssName.lastIndexOf("/")+1);
                    if (expectedStyleNames.includes(cssBaseName)) {
                        const localCssUrl = `/arxiv_styles/${cssBaseName}`;
                        styles += await fetch(localCssUrl).then(res => {
                            if (!res.ok) throw new Error(`Failed to fetch local CSS: ${localCssUrl}`);
                            return res.text();
                        });
                    } else {
                        const localCssUrl = `/arxiv_styles/${expectedStyleNames[0]}`;
                        console.warn(`Our local CSS is outdated. Please report to developer: ${cssName} -> ${localCssUrl}`);
                        styles += await fetch(localCssUrl).then(res => {
                            if (!res.ok) throw new Error(`Failed to fetch local CSS: ${localCssUrl}`);
                            return res.text();
                        });
                    }
                }
                // Extract images
                const imgMapper = new Map();
                const imgElements = article.querySelectorAll("img");
                for (const imgElm of imgElements) {
                    const src = imgElm.getAttribute("src");
                    if (src && !src.startsWith("data:")) {
                        // replace with base64
                        const imgUrl = new URL(src, url).href;
                        const imgBlob = await fetch(imgUrl).then(res => {
                            if (!res.ok) throw new Error(`Failed to fetch image: ${imgUrl}`);
                            return res.blob();
                        });
                        const reader = new FileReader();
                        const dataUrl = await new Promise((resolve, reject) => {
                            reader.onloadend = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(imgBlob);
                        });
                        imgMapper.set(imgElm.id, {elm: imgElm, url: dataUrl, blob: imgBlob});
                        imgElm.setAttribute("src", dataUrl);
                    }
                }
                // Sanitize buttons
                article.querySelectorAll("button").forEach(btn => btn.remove());
                // Localize links
                const linkElements = article.querySelectorAll("a");
                for (const linkElm of linkElements) {
                    const href = linkElm.getAttribute("href");
                    const currentUrl = new URL(url);
                    if (href) {
                        const absUrl = new URL(href, url);
                        if (absUrl.origin === currentUrl.origin && absUrl.pathname === currentUrl.pathname) {
                            // link to the same page
                            linkElm.setAttribute("href", absUrl.hash);
                        } else {
                            // external link. remove it.
                            linkElm.setAttribute("href", "#");
                        }
                    } else {
                        linkElm.setAttribute("href", "#");
                    }
                }
                // Create Preview HTML
                infoMessage("Creating preview...");
                const previewHtml = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${title}</title>
  <style>${styles}</style>
</head>
<body>
  <div class="ltx_page_main" id="main">
    <div class="ltx_page_content">
      ${watermarkElm?.outerHTML || ""}
      <article class="ltx_document ltx_authors_1line">
        ${titleElm?.outerHTML || ""}
        ${authorsElm?.outerHTML || ""}
        ${abstElm?.outerHTML || ""}
        ${sections.map(sec => sec.outerHTML).join("\n")}
      </article>
    </div>
  </div>
</body>
</html>`;
                previewFrame.srcdoc = previewHtml;
                previewDiv.style.display = "block";

                // Create EPUB
                infoMessage("Converting to EPUB...");
                const zip = new JSZip();
                zip.file("mimetype", "application/epub+zip");

                // insert CSS
                zip.file("EPUB/style.css", styles);

                // Rewrite image src to local files
                const imageManifests = [];
                for (const [id, imgData] of imgMapper) {
                    const imgElm = imgData.elm;
                    if (imgElm) {
                        const ext = imgData.blob.type.split("/")[1] || "png";
                        const localFileName = `images/${id}.${ext}`;
                        imgElm.setAttribute("src", localFileName);
                        zip.file(`EPUB/images/${id}.${ext}`, imgData.blob, {binary: true});
                        imageManifests.push(`<item id="${id}" href="images/${id}.${ext}" media-type="${imgData.blob.type}"/>`);
                    }
                }

                const chapters = sections.map(sec => (
                    `<item id="${sec.id}" href="${sec.id}.xhtml" media-type="application/xhtml+xml"/>`
                ));
                const spines = sections.map(sec => (
                    `<itemref idref="${sec.id}"/>`
                ));

                zip.file("META-INF/container.xml",
`<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="EPUB/content.opf" media-type="application/oebps-package+xml"/>
  </rootfiles>
</container>`);

                zip.file("EPUB/content.opf",
`<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="pub-id" version="3.0">
  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
    <dc:identifier id="pub-id">urn:uuid:${crypto.randomUUID()}</dc:identifier>
    <dc:title>${escapeXml(title)}</dc:title>
    <dc:language>en</dc:language>
    <meta property="dcterms:modified">${new Date().toISOString().slice(0,19)}Z</meta>
  </metadata>
  <manifest>
    <item href="style.css" id="style" media-type="text/css"/>
    <item href="nav.xhtml" id="nav" media-type="application/xhtml+xml" properties="nav"/>
    <item href="first.xhtml" id="first" media-type="application/xhtml+xml"/>
    ${chapters.join("\n")}
    ${imageManifests.join("\n")}
  </manifest>
  <spine>
    <itemref idref="first"/>
    ${spines.join("\n")}
  </spine>
</package>`);

                const navs = sections.map(sec => (
                    `<li><a href="${sec.id}.xhtml">${escapeXml(sec.querySelector(".ltx_title_section")?.textContent || sec.id)}</a></li>`
                ));
                zip.file("EPUB/nav.xhtml",
`<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
  <head>
    <meta charset="UTF-8"/>
    <title>Table of Contents</title>
  </head>
  <body>
    <nav epub:type="toc" id="id" role="doc-toc">
      <h2>Table of Contents</h2>
      <ol>
        <li><a href="first.xhtml">Title</a></li>
        ${navs.join("\n")}
      </ol>
    </nav>
  </body>
</html>`);

                zip.file("EPUB/first.xhtml",
`<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="ja" xml:lang="ja">
  <head>
    <meta charset="UTF-8">
    <title>${escapeXml(title)}</title>
    <link rel="stylesheet" type="text/css" href="style.css" />
  </head>
<body>
  <div class="ltx_page_main" id="main">
    <div class="ltx_page_content">
      ${watermarkElm?.outerHTML || ""}
      <article class="ltx_document ltx_authors_1line">
        ${titleElm?.outerHTML || ""}
        ${authorsElm?.outerHTML || ""}
        ${abstElm?.outerHTML || ""}
      </article>
    </div>
  </div>
</body>
</html>`);

                // FIXME: style.css breaks Kindle Previewer in bib.xhtml
                sections.forEach(sec => {
                    zip.file(`EPUB/${sec.id}.xhtml`,
`<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="ja" xml:lang="ja">
  <head>
    <meta charset="UTF-8">
    <title>${escapeXml(title)}</title>
    ${sec.id === "bib" ? "" : `<link rel="stylesheet" type="text/css" href="style.css" />`}
  </head>
<body>
  <div class="ltx_page_main" id="main">
    <div class="ltx_page_content">
      <article class="ltx_document ltx_authors_1line">
        ${sec.outerHTML}
      </article>
    </div>
  </div>
</body>
</html>`);});

                const epubBlob = await zip.generateAsync({type:"blob", mimeType:"application/epub+zip"});
                const epubUrl = URL.createObjectURL(epubBlob);
                const a = document.createElement("a");
                a.href = epubUrl;
                a.download = `${id}.epub`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(epubUrl);
                infoMessage("EPUB file is ready for download.");
            } catch (err) {
                errorMessage(err.message);
            } finally {
                convertButton.disabled = false;
            }

        });

    </script>
</body>
</html>